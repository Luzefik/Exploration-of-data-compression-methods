# Дослiдження методiв компресiї даних та створення власної програми-кодека
> Виконаний командою 12 у межах курсу "Дискретна математика 2".

Під час роботи над цим комп'ютерним проєктом ми розглянули різні методи компресії даних. <br>
У роботі реалізовані алгоритми: 
- Код Хаффмана (Huffman Coding)
- LZ77
- LZ78
- LZW
- DEFLATE
- RLE

## Код Хаффмана (Huffman Coding) - Оксана Москв'як
> Реалізація алгоритму `Huffman’s coding`  - алгоритм префіксного кодування з мінімальною надмірністю, заснованого на побудові дерева Хаффмана як основної структури. Алгоритм закодовує певні послідовності, надаючи найбільш використовуваним послідовностям коди найменшої довжини, і навпаки.

### Основні компоненти:

Клас `node` , який використовується для зберігання інформації у структурі дерева Хаффмана.

Функція `char_frequency` - будує словник частоти значень для початкових даних.

Функція `codes_generation`   - рекурсивно присвоює бінарні коди кожному символу, безпосередньо використовуючи структуру дерева та роботу із вершинами, що містять основну інформацію про кількість символів. В основі цього лежить pre-order обхід, який це забезпечує

Функція `tree` - будує дерево Гаффмана, об’єднуючи дві вершини із найменшим значенням (частотою), через використання структури min-heap, тобто повного бінарного дерева, де кожна вершина менша або дорівнює своїм синам. Процес триває доки не залишиться одна вершина, тобто корінь дерева.

Функція `compress_file` - виконує основну мету алгоритму - закодування файлу та збереження необхідних для декомпресії даних. Спочатку читаємо, отриманий від користувача файл за допомогою `mmap`. Отримуємо масив байтів, що відповідають нашому файлу. Наступним кроком відбувається перевірка чи не побудовано вже дерева, тоді створюється словник, створюються вершини, безпосередньо беручи участь в реалізації дерева Гаффмана, далі створюється дерево і генеруються бінарні коди. Інформація перетворюється у біти `bitarray`  через додавання бітового рядка для кожного символу до кінцевого потоку бітів, задля збереження довжини справжнього закодованого файлу та об’єднання значень із словника в послідовність, яка була першочергово. Як результат отримуємо файл з розширенням `.bin` , що містить закодовану інформацію про файл та файл `.json` , який містить словник кодів та значень, розширення початкового файлу та довжину справжньої інформації.

Функція `decompress_file` - виконує декомпресування стиснутого раніше файлу. Дані зчитуються у масив бітів `bitarray` та згодом обрізаються згідно з довжиною справжньої інформації, отриманої із словника. Запускаємо цикл, який ітерується по наших даних, шукаючи в словнику відповідну послідовність. Коли цю послідовність знайдено, то її додано до загального результату. Відновленні дані записуються у файл із початковим розширенням, яке ми дістали із словника.

#### Використані структури/модулі 

- `mmap` - для зменшення використання фізичної пам’яті, універсальності читання різноманітних файлів.
- `deque` - для видалення переглянутого "декодованого" знаку
- `defaultdict` - у створенні словника, який зберігає кількість використання певного знаку
- `bitarray` - для збереження результату кодування із байтів у біти та навпаки.
- `heapq` - використовується як структура min-heap - повне бінарне дерево, корінь якого має найменше значення серед усіх його нащадків, це має виконуватись для лівого і правого піддерев, потрібна щоб об'єднати дві вершини мінімального значення в 1 при побудові.

## LZ77 - Андрій Кульбаба
> Реалізація алгоритму стиснення LZ77, заснованого на принципі ковзного вікна (sliding window). <br>Алгоритм знаходить повторювані послідовності байтів у нещодавно оброблених даних і замінює їх <br>посиланнями формату (відстань назад, довжина збігу). Байти, що не мають збігів, кодуються як є (літерали).

### Основні компоненти:
`Клас LZ77`:
Інкапсулює всю логіку стиснення та декомпресії. Має конфігурований розмір ковзного вікна `window_size` та фіксований розмір буфера попереднього перегляду `lookahead_buffer_size`. <br>

Функція `find_match`:<br>
- Здійснює пошук найдовшого збігу для поточної позиції даних у межах ковзного вікна.
- Використовує хеш-таблицю `dict` для швидкого пошуку потенційних кандидатів на збіг (індексує позиції за хешем 3-байтових послідовностей).
- Оптимізація: Включає механізм очищення хеш-таблиці від застарілих записів (позицій, що вийшли за межі ковзного вікна) перед перебором кандидатів, що прискорює пошук у великих файлах. Очищення реалізоване через list comprehension. <br>

Функція `compress_file`:
- Виконує процес стиснення файлу.
- Читає вхідний файл за допомогою mmap та використовує `memoryview` для ефективного доступу до даних без зайвого копіювання.
- Ітерує по даних, викликаючи `find_match` для пошуку збігів.
- Формує вихідний стиснений потік бітів за допомогою бібліотеки `bitarray`. Схема кодування:
- Збіг: 1 біт-прапорець `True` + 16 бітів (12 біт відстань, 4 біти довжина).
- Літерал: 1 біт-прапорець `False` + 8 бітів (байт літерала).
- Метадані: Зберігає на початку стисненого файлу інформацію про розширення оригінального файлу (довжину та самі байти розширення), використовуючи модуль struct.

  
Функція `decompress_file`:
- Виконує процес декомпресії.
- Читає метадані (розширення) з початку файлу.
- Читає основний потік стиснених даних у bitarray.
- Декодує бітовий потік, розрізняючи літерали та пари (відстань, довжина) за прапорцем.
- Відтворює оригінальні дані в bytearray, або додаючи літерали, або копіюючи послідовності з уже декодованої частини буфера відповідно до (відстань, довжина).
- Записує відновлені дані у вихідний файл із збереженим оригінальним розширенням.

#### Використані структури/модулі:

- `mmap / memoryview`: Для ефективної роботи з файлами та доступу до даних в пам'яті.
- `dict (хеш-таблиця)`: Для індексації позицій та прискорення пошуку збігів.
- `bitarray`: Для гнучкої роботи з бітовими потоками змінної довжини.
- `struct`: Для пакування/розпакування бінарних метаданих (інформації про розширення).
- `List comprehension`: Використовується для реалізації механізму очищення хеш-таблиці.


## LZ78 - Олег Гуцуляк
> Алгоритм LZ78 реалізований як клас `LZ78Compressor`, що включає методи для стиснення та розпакування файлів і даних.

### Основні компоненти:

Метод `compress(data: bytes)` приймає байтові дані та виконує стиснення за допомогою словника, який будується динамічно. Алгоритм зчитує послідовності байтів, які вже зустрічалися, і замінює їх індексами в словнику разом з наступним байтом. Повертається список пар `(індекс, байт)`.

Метод `decompress(pairs: list[tuple[int, bytes]])` приймає список пар `(індекс, байт)` та динамічно будує словник для відновлення оригінальних даних. Починаючи з пустого словника, він реконструює кожен фрагмент і об’єднує їх у повні дані. Повертає розпаковані байти.

Метод `compress_file(input_path: str, output_path: str)` зчитує файл у байтовому форматі, стискає вміст за допомогою `compress`, і зберігає стиснені пари у бінарному файлі. Індекси зберігаються як 4 байти, після чого йде сам байт.

Метод `decompress_file(input_path: str, output_path: str)` читає бінарний файл, інтерпретує його як послідовність стиснених пар `(індекс, байт)` і відновлює початкові байти за допомогою `decompress`. Відновлені дані записуються у вивідний файл.

#### Використані структури/модулі:

- `dict` — використовується як словник для збереження повторних послідовностей під час стиснення та розпакування.

- `bytearray` — застосовується для ефективного зберігання результату під час розпакування.

- `int.to_bytes` і `int.from_bytes` — вбудовані методи Python для перетворення цілих чисел у байти та навпаки, що дозволяє працювати з файлами без потреби в зовнішніх бібліотеках.

Цей підхід дозволяє стискати будь-які типи файлів, оскільки працює з байтами, а не рядками.

## LZW - Олександр Стаднік
> Алгоритм LZW реалізований як клас LZWCompressor, що включає методи для стиснення та розпакування файлів.

### Основні компоненти:
Метод `compress` приймає байтові дані та виконує стиснення за допомогою динамічного словника, який будується під час обробки даних.

Метод `decompress` приймає стиснені дані у вигляді списку чисел і відновлює початкові байти, використовуючи словник, який також динамічно будується.

Метод `compress_file` дозволяє стискати файли, зчитуючи їх у байтовому форматі, стискаючи дані та зберігаючи результат у двійковому форматі.

Метод `decompress_file` дозволяє розпаковувати файли, зчитуючи стиснені дані у двійковому форматі, відновлюючи початкові дані та зберігаючи їх у файл.

#### Використані структури:

- `dict` - для зберігання словника під час стиснення та розпакування.
- `bytearray` - для ефективного зберігання результату розпакування.

## RLE - Олег Гуцуляк
> Алгоритм RLE реалізований як клас `RLECompressor`, що включає методи для стиснення та розпакування файлів і байтових даних.

### Основні компоненти:
Метод `compress(data: bytes)` приймає послідовність байтів і стискає повторювані символи. Алгоритм знаходить серії однакових байтів та замінює їх парою `(count, byte)`. Наприклад, `AAAA` → `(4, A)`. Повертає список пар `(count: int, byte: bytes)`.

Метод `decompress(pairs: list[tuple[int, bytes]])` приймає список пар `(count, byte)` та відновлює оригінальну послідовність байтів, повторюючи кожен байт `count` разів. Повертає розпаковані байти.

Метод `compress_file(input_path: str, output_path: str)` читає вхідний файл у байтовому режимі, стискає вміст за допомогою `compress`, і записує у вихідний `.bin` файл. Кожна пара `(count, byte)` записується як: 1 байт для кількості (max 255) + 1 байт значення.

Метод `decompress_file(input_path: str, output_path: str)` читає стиснений файл у вигляді послідовності пар `(count, byte)` і відновлює повні байти. Результат записується у файл в оригінальному форматі.

#### Використані структури:

- `bytearray` — використовується для поступового зберігання результату у пам’яті при декомпресії.

- `int.to_bytes` і `int.from_bytes` — використовуються для кодування числових значень у байти (і навпаки), що забезпечує сумісність із будь-яким типом файлу.

> **Примітка:** Через свою простоту, RLE ефективно стискає лише дані з великою кількістю повторюваних байтів (наприклад, монохромні зображення або послідовності з нулями). У випадках із складними, неповторюваними даними, алгоритм може навіть збільшити розмір файлу.

## DEFLATE - Андрій Кульбаба

## UI та тестування - Оксана Москв'як
![image](https://github.com/user-attachments/assets/24c5d03f-13a5-4ef6-8043-fd31735a5a3f)
*Інтерфейс програми-кодека під час початку роботи*
<br>
<img width="788" alt="Screenshot 2025-05-07 at 10 05 36" src="https://github.com/user-attachments/assets/4b594776-2e4f-4665-b97f-608deca7babc" /> <br>
*Інтерфейс програми-кодека після компресії файлу. Зображено початковий розмір файлу та розмір стисненого файлу.*

Використані бібліотеки для UI:
- `PyQt6` - для безпосереднього створення застосунку.
- `os` - для доступу до файлів.
- `sys` - для запуску ui.

### Основні компоненти:
