# Дослiдження методiв компресiї даних та створення власної програми-кодека
> Виконаний командою 12 у межах курсу "Дискретна математика 2".

Під час роботи над цим комп'ютерним проєктом ми розглянули різні методи компресії даних. <br>
У роботі реалізовані алгоритми: 
- Код Хаффмана (Huffman Coding)
- LZ77
- LZ78
- LZW
- DEFLATE
- RLE

## Код Хаффмана (Huffman Coding) - Оксана Москв'як

## LZ77 - Андрій Кульбаба
> Реалізація алгоритму стиснення LZ77, заснованого на принципі ковзного вікна (sliding window). <br>Алгоритм знаходить повторювані послідовності байтів у нещодавно оброблених даних і замінює їх <br>посиланнями формату (відстань назад, довжина збігу). Байти, що не мають збігів, кодуються як є (літерали).

### Основні компоненти:
`Клас LZ77`:
Інкапсулює всю логіку стиснення та декомпресії. Має конфігурований розмір ковзного вікна `window_size` та фіксований розмір буфера попереднього перегляду `lookahead_buffer_size`. <br>

Функція `find_match`:<br>
- Здійснює пошук найдовшого збігу для поточної позиції даних у межах ковзного вікна.
- Використовує хеш-таблицю `dict` для швидкого пошуку потенційних кандидатів на збіг (індексує позиції за хешем 3-байтових послідовностей).
- Оптимізація: Включає механізм очищення хеш-таблиці від застарілих записів (позицій, що вийшли за межі ковзного вікна) перед перебором кандидатів, що прискорює пошук у великих файлах. Очищення реалізоване через list comprehension. <br>

Функція `compress_file`:
- Виконує процес стиснення файлу.
- Читає вхідний файл за допомогою mmap та використовує `memoryview` для ефективного доступу до даних без зайвого копіювання.
- Ітерує по даних, викликаючи `find_match` для пошуку збігів.
- Формує вихідний стиснений потік бітів за допомогою бібліотеки `bitarray`. Схема кодування:
- Збіг: 1 біт-прапорець `True` + 16 бітів (12 біт відстань, 4 біти довжина).
- Літерал: 1 біт-прапорець `False` + 8 бітів (байт літерала).
- Метадані: Зберігає на початку стисненого файлу інформацію про розширення оригінального файлу (довжину та самі байти розширення), використовуючи модуль struct.

  
Функція `decompress_file`:
- Виконує процес декомпресії.
- Читає метадані (розширення) з початку файлу.
- Читає основний потік стиснених даних у bitarray.
- Декодує бітовий потік, розрізняючи літерали та пари (відстань, довжина) за прапорцем.
- Відтворює оригінальні дані в bytearray, або додаючи літерали, або копіюючи послідовності з уже декодованої частини буфера відповідно до (відстань, довжина).
- Записує відновлені дані у вихідний файл із збереженим оригінальним розширенням.

#### Використані структури/модулі:

- `mmap / memoryview`: Для ефективної роботи з файлами та доступу до даних в пам'яті.
- `dict (хеш-таблиця)`: Для індексації позицій та прискорення пошуку збігів.
- `bitarray`: Для гнучкої роботи з бітовими потоками змінної довжини.
- `struct`: Для пакування/розпакування бінарних метаданих (інформації про розширення).
- `List comprehension`: Використовується для реалізації механізму очищення хеш-таблиці.


## LZ78 - Олег Гуцуляк
> Алгоритм LZ78 реалізований як клас `LZ78Compressor`, що включає методи для стиснення та розпакування файлів і даних.

### Основні компоненти:

Метод `compress(data: bytes)` приймає байтові дані та виконує стиснення за допомогою словника, який будується динамічно. Алгоритм зчитує послідовності байтів, які вже зустрічалися, і замінює їх індексами в словнику разом з наступним байтом. Повертається список пар `(індекс, байт)`.

Метод `decompress(pairs: list[tuple[int, bytes]])` приймає список пар `(індекс, байт)` та динамічно будує словник для відновлення оригінальних даних. Починаючи з пустого словника, він реконструює кожен фрагмент і об’єднує їх у повні дані. Повертає розпаковані байти.

Метод `compress_file(input_path: str, output_path: str)` зчитує файл у байтовому форматі, стискає вміст за допомогою `compress`, і зберігає стиснені пари у бінарному файлі. Індекси зберігаються як 4 байти, після чого йде сам байт.

Метод `decompress_file(input_path: str, output_path: str)` читає бінарний файл, інтерпретує його як послідовність стиснених пар `(індекс, байт)` і відновлює початкові байти за допомогою `decompress`. Відновлені дані записуються у вивідний файл.

#### Використані структури/модулі:

- `dict` — використовується як словник для збереження повторних послідовностей під час стиснення та розпакування.

- `bytearray` — застосовується для ефективного зберігання результату під час розпакування.

- `int.to_bytes` і `int.from_bytes` — вбудовані методи Python для перетворення цілих чисел у байти та навпаки, що дозволяє працювати з файлами без потреби в зовнішніх бібліотеках.

Цей підхід дозволяє стискати будь-які типи файлів, оскільки працює з байтами, а не рядками.

## LZW - Олександр Стаднік
> Алгоритм LZW реалізований як клас LZWCompressor, що включає методи для стиснення та розпакування файлів.

### Основні компоненти:
Метод `compress` приймає байтові дані та виконує стиснення за допомогою динамічного словника, який будується під час обробки даних.

Метод `decompress` приймає стиснені дані у вигляді списку чисел і відновлює початкові байти, використовуючи словник, який також динамічно будується.

Метод `compress_file` дозволяє стискати файли, зчитуючи їх у байтовому форматі, стискаючи дані та зберігаючи результат у двійковому форматі.

Метод `decompress_file` дозволяє розпаковувати файли, зчитуючи стиснені дані у двійковому форматі, відновлюючи початкові дані та зберігаючи їх у файл.

#### Використані структури:

- `dict` - для зберігання словника під час стиснення та розпакування.
- `bytearray` - для ефективного зберігання результату розпакування.

## RLE - Олег Гуцуляк
> Алгоритм RLE реалізований як клас `RLECompressor`, що включає методи для стиснення та розпакування файлів і байтових даних.

### Основні компоненти:
Метод `compress(data: bytes)` приймає послідовність байтів і стискає повторювані символи. Алгоритм знаходить серії однакових байтів та замінює їх парою `(count, byte)`. Наприклад, `AAAA` → `(4, A)`. Повертає список пар `(count: int, byte: bytes)`.

Метод `decompress(pairs: list[tuple[int, bytes]])` приймає список пар `(count, byte)` та відновлює оригінальну послідовність байтів, повторюючи кожен байт `count` разів. Повертає розпаковані байти.

Метод `compress_file(input_path: str, output_path: str)` читає вхідний файл у байтовому режимі, стискає вміст за допомогою `compress`, і записує у вихідний `.bin` файл. Кожна пара `(count, byte)` записується як: 1 байт для кількості (max 255) + 1 байт значення.

Метод `decompress_file(input_path: str, output_path: str)` читає стиснений файл у вигляді послідовності пар `(count, byte)` і відновлює повні байти. Результат записується у файл в оригінальному форматі.

#### Використані структури:

- `bytearray` — використовується для поступового зберігання результату у пам’яті при декомпресії.

- `int.to_bytes` і `int.from_bytes` — використовуються для кодування числових значень у байти (і навпаки), що забезпечує сумісність із будь-яким типом файлу.

> **Примітка:** Через свою простоту, RLE ефективно стискає лише дані з великою кількістю повторюваних байтів (наприклад, монохромні зображення або послідовності з нулями). У випадках із складними, неповторюваними даними, алгоритм може навіть збільшити розмір файлу.

## DEFLATE - Андрій Кульбаба

## UI та тестування - Оксана Москв'як
