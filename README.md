# Дослiдження методiв компресiї даних та створення власної програми-кодека
> Виконаний командою 12 у межах курсу "Дискретна математика 2".

Під час роботи над цим комп'ютерним проєктом ми розглянули різні методи компресії даних. <br>
У роботі реалізовані алгоритми: 
- Код Хаффмана (Huffman Coding)
- LZ77
- LZ78
- LZW
- DEFLATE
- RLE
Додатково: 
- DPCM для роботи з .wav 

## Код Хаффмана (Huffman Coding) - Оксана Москв'як
> Реалізація алгоритму `Huffman’s coding`  - алгоритм префіксного кодування з мінімальною надмірністю, заснованого на побудові дерева Хаффмана як основної структури. Алгоритм закодовує певні послідовності, надаючи найбільш використовуваним послідовностям коди найменшої довжини, і навпаки.

### Основні компоненти:

Клас `node` , який використовується для зберігання інформації у структурі дерева Хаффмана.

Функція `char_frequency` - будує словник частоти значень для початкових даних.

Функція `codes_generation`   - рекурсивно присвоює бінарні коди кожному символу, безпосередньо використовуючи структуру дерева та роботу із вершинами, що містять основну інформацію про кількість символів. В основі цього лежить pre-order обхід, який це забезпечує

Функція `tree` - будує дерево Гаффмана, об’єднуючи дві вершини із найменшим значенням (частотою), через використання структури min-heap, тобто повного бінарного дерева, де кожна вершина менша або дорівнює своїм синам. Процес триває доки не залишиться одна вершина, тобто корінь дерева.

Функція `compress_file` - виконує основну мету алгоритму - закодування файлу та збереження необхідних для декомпресії даних. Спочатку читаємо, отриманий від користувача файл за допомогою `mmap`. Отримуємо масив байтів, що відповідають нашому файлу. Наступним кроком відбувається перевірка чи не побудовано вже дерева, тоді створюється словник, створюються вершини, безпосередньо беручи участь в реалізації дерева Гаффмана, далі створюється дерево і генеруються бінарні коди. Інформація перетворюється у біти `bitarray`  через додавання бітового рядка для кожного символу до кінцевого потоку бітів, задля збереження довжини справжнього закодованого файлу та об’єднання значень із словника в послідовність, яка була першочергово. Як результат отримуємо файл з розширенням `.bin` , що містить закодовану інформацію про файл та файл `.json` , який містить словник кодів та значень, розширення початкового файлу та довжину справжньої інформації.

Функція `decompress_file` - виконує декомпресування стиснутого раніше файлу. Дані зчитуються у масив бітів `bitarray` та згодом обрізаються згідно з довжиною справжньої інформації, отриманої із словника. Запускаємо цикл, який ітерується по наших даних, шукаючи в словнику відповідну послідовність. Коли цю послідовність знайдено, то її додано до загального результату. Відновленні дані записуються у файл із початковим розширенням, яке ми дістали із словника.

#### Використані структури/модулі 

- `mmap` - для зменшення використання фізичної пам’яті, універсальності читання різноманітних файлів.
- `deque` - для видалення переглянутого "декодованого" знаку
- `defaultdict` - у створенні словника, який зберігає кількість використання певного знаку
- `bitarray` - для збереження результату кодування із байтів у біти та навпаки.
- `heapq` - використовується як структура min-heap - повне бінарне дерево, корінь якого має найменше значення серед усіх його нащадків, це має виконуватись для лівого і правого піддерев, потрібна щоб об'єднати дві вершини мінімального значення в 1 при побудові.

## LZ77 - Андрій Кульбаба
> Реалізація алгоритму стиснення LZ77, заснованого на принципі ковзного вікна (sliding window). <br>Алгоритм знаходить повторювані послідовності байтів у нещодавно оброблених даних і замінює їх <br>посиланнями формату (відстань назад, довжина збігу). Байти, що не мають збігів, кодуються як є (літерали).

### Основні компоненти:
`Клас LZ77`:
Інкапсулює всю логіку стиснення та декомпресії. Має конфігурований розмір ковзного вікна `window_size` та фіксований розмір буфера попереднього перегляду `lookahead_buffer_size`. <br>

Функція `find_match`:<br>
- Здійснює пошук найдовшого збігу для поточної позиції даних у межах ковзного вікна.
- Використовує хеш-таблицю `dict` для швидкого пошуку потенційних кандидатів на збіг (індексує позиції за хешем 3-байтових послідовностей).
- Оптимізація: Включає механізм очищення хеш-таблиці від застарілих записів (позицій, що вийшли за межі ковзного вікна) перед перебором кандидатів, що прискорює пошук у великих файлах. Очищення реалізоване через list comprehension. <br>

Функція `compress_file`:
- Виконує процес стиснення файлу.
- Читає вхідний файл за допомогою mmap та використовує `memoryview` для ефективного доступу до даних без зайвого копіювання.
- Ітерує по даних, викликаючи `find_match` для пошуку збігів.
- Формує вихідний стиснений потік бітів за допомогою бібліотеки `bitarray`. Схема кодування:
- Збіг: 1 біт-прапорець `True` + 16 бітів (12 біт відстань, 4 біти довжина).
- Літерал: 1 біт-прапорець `False` + 8 бітів (байт літерала).
- Метадані: Зберігає на початку стисненого файлу інформацію про розширення оригінального файлу (довжину та самі байти розширення), використовуючи модуль struct.

  
Функція `decompress_file`:
- Виконує процес декомпресії.
- Читає метадані (розширення) з початку файлу.
- Читає основний потік стиснених даних у bitarray.
- Декодує бітовий потік, розрізняючи літерали та пари (відстань, довжина) за прапорцем.
- Відтворює оригінальні дані в bytearray, або додаючи літерали, або копіюючи послідовності з уже декодованої частини буфера відповідно до (відстань, довжина).
- Записує відновлені дані у вихідний файл із збереженим оригінальним розширенням.

#### Використані структури/модулі:

- `mmap / memoryview`: Для ефективної роботи з файлами та доступу до даних в пам'яті.
- `dict (хеш-таблиця)`: Для індексації позицій та прискорення пошуку збігів.
- `bitarray`: Для гнучкої роботи з бітовими потоками змінної довжини.
- `struct`: Для пакування/розпакування бінарних метаданих (інформації про розширення).
- `List comprehension`: Використовується для реалізації механізму очищення хеш-таблиці.


## LZ78 - Олег Гуцуляк
> Алгоритм LZ78 реалізований як клас `LZ78Compressor`, що включає методи для стиснення та розпакування файлів і даних.

### Основні компоненти:

Метод `compress(data: bytes)` приймає байтові дані та виконує стиснення за допомогою словника, який будується динамічно. Алгоритм зчитує послідовності байтів, які вже зустрічалися, і замінює їх індексами в словнику разом з наступним байтом. Повертається список пар `(індекс, байт)`.

Метод `decompress(pairs: list[tuple[int, bytes]])` приймає список пар `(індекс, байт)` та динамічно будує словник для відновлення оригінальних даних. Починаючи з пустого словника, він реконструює кожен фрагмент і об’єднує їх у повні дані. Повертає розпаковані байти.

Метод `compress_file(input_path: str, output_path: str)` зчитує файл у байтовому форматі, стискає вміст за допомогою `compress`, і зберігає стиснені пари у бінарному файлі. Індекси зберігаються як 4 байти, після чого йде сам байт.

Метод `decompress_file(input_path: str, output_path: str)` читає бінарний файл, інтерпретує його як послідовність стиснених пар `(індекс, байт)` і відновлює початкові байти за допомогою `decompress`. Відновлені дані записуються у вивідний файл.

#### Використані структури/модулі:

- `dict` — використовується як словник для збереження повторних послідовностей під час стиснення та розпакування.

- `bytearray` — застосовується для ефективного зберігання результату під час розпакування.

- `int.to_bytes` і `int.from_bytes` — вбудовані методи Python для перетворення цілих чисел у байти та навпаки, що дозволяє працювати з файлами без потреби в зовнішніх бібліотеках.

Цей підхід дозволяє стискати будь-які типи файлів, оскільки працює з байтами, а не рядками.

## LZW - Олександр Стаднік
> Алгоритм LZW реалізований як клас LZWCompressor, що включає методи для стиснення та розпакування файлів.

### Основні компоненти:
Метод `compress` приймає байтові дані та виконує стиснення за допомогою динамічного словника, який будується під час обробки даних.

Метод `decompress` приймає стиснені дані у вигляді списку чисел і відновлює початкові байти, використовуючи словник, який також динамічно будується.

Метод `compress_file` дозволяє стискати файли, зчитуючи їх у байтовому форматі, стискаючи дані та зберігаючи результат у двійковому форматі.

Метод `decompress_file` дозволяє розпаковувати файли, зчитуючи стиснені дані у двійковому форматі, відновлюючи початкові дані та зберігаючи їх у файл.

#### Використані структури:

- `dict` - для зберігання словника під час стиснення та розпакування.
- `bytearray` - для ефективного зберігання результату розпакування.

## RLE - Олег Гуцуляк
> Алгоритм RLE реалізований як клас `RLECompressor`, що включає методи для стиснення та розпакування файлів і байтових даних.

### Основні компоненти:
Метод `compress(data: bytes)` приймає послідовність байтів і стискає повторювані символи. Алгоритм знаходить серії однакових байтів та замінює їх парою `(count, byte)`. Наприклад, `AAAA` → `(4, A)`. Повертає список пар `(count: int, byte: bytes)`.

Метод `decompress(pairs: list[tuple[int, bytes]])` приймає список пар `(count, byte)` та відновлює оригінальну послідовність байтів, повторюючи кожен байт `count` разів. Повертає розпаковані байти.

Метод `compress_file(input_path: str, output_path: str)` читає вхідний файл у байтовому режимі, стискає вміст за допомогою `compress`, і записує у вихідний `.bin` файл. Кожна пара `(count, byte)` записується як: 1 байт для кількості (max 255) + 1 байт значення.

Метод `decompress_file(input_path: str, output_path: str)` читає стиснений файл у вигляді послідовності пар `(count, byte)` і відновлює повні байти. Результат записується у файл в оригінальному форматі.

#### Використані структури:

- `bytearray` — використовується для поступового зберігання результату у пам’яті при декомпресії.

- `int.to_bytes` і `int.from_bytes` — використовуються для кодування числових значень у байти (і навпаки), що забезпечує сумісність із будь-яким типом файлу.

> **Примітка:** Через свою простоту, RLE ефективно стискає лише дані з великою кількістю повторюваних байтів (наприклад, монохромні зображення або послідовності з нулями). У випадках із складними, неповторюваними даними, алгоритм може навіть збільшити розмір файлу.

## DEFLATE - Андрій Кульбаба
> Реалізація алгоритму стиснення DEFLATE, який є комбінацією двох методів: пошуку повторів (схожого на LZ77) та ефективного кодування символів (кодування Хаффмана). Цей підхід дозволяє досягти високого ступеня стиснення даних.

### Загальний принцип роботи:

Алгоритм працює у два основні етапи:

1.  **Пошук та заміна повторюваних фрагментів:** Програма переглядає дані і шукає послідовності байтів, які вже зустрічалися раніше. Замість того, щоб зберігати ці повтори знову, вона замінює їх спеціальними посиланнями. Посилання вказує, наскільки далеко назад потрібно "подивитися" і скільки байтів скопіювати. Байти, для яких повторів не знайдено, залишаються як є (їх називають літералами).
2.  **Кодування літералів та посилань:** Отримана послідовність літералів та посилань далі стискається за допомогою кодів Хаффмана. Цей метод присвоює символам (або посиланням), що зустрічаються частіше, коротші коди, а тим, що рідше – довші. У цій реалізації використовуються стандартні, заздалегідь визначені (фіксовані) коди Хаффмана.

### Основні компоненти реалізації:

* **Клас `Deflate`**: Головний організатор процесу стиснення та розпакування. Він координує роботу етапу пошуку повторів (LZ77) та етапу кодування Хаффманом.

* **Клас `LZ77` (внутрішній компонент)**: Відповідає за перший етап – знаходження повторюваних послідовностей даних за допомогою методу "ковзного вікна". Він повертає потік, що складається з літералів та посилань (довжина збігу, відстань до нього).

* **Функції для генерації кодів Хаффмана (`_get_fixed_lit_len_encoding_map` та `_get_fixed_dist_encoding_map`)**: Створюють таблиці кодів для фіксованих дерев Хаффмана. Ці таблиці стандартні для DEFLATE і використовуються для кодування літералів, довжин збігів та відстаней.

* **Функція `compress_file`**:
    * Спочатку обробляє файл за допомогою логіки LZ77, отримуючи літерали та пари (довжина, відстань).
    * Далі формує бітовий потік:
        * Записує спеціальний заголовок, що вказує на використання фіксованих кодів Хаффмана.
        * Кодує кожен літерал або довжину збігу відповідним кодом Хаффмана.
        * Якщо це збіг, додатково записує закодовану відстань.
        * В кінці додає спеціальний маркер завершення блоку даних.
    * Зберігає невелику службову інформацію (розширення вихідного файлу) на початку стисненого файлу.

* **Функція `decompress_file`**:
    * Зчитує службову інформацію.
    * Обробляє стиснений потік даних блок за блоком.
    * Для кожного блоку, що використовує фіксовані коди Хаффмана:
        * Декодує символи за допомогою таблиць Хаффмана.
        * Якщо символ – літерал, він додається до вихідних даних.
        * Якщо символ позначає кінець блоку, обробка блоку завершується.
        * Якщо символ – це довжина збігу, то далі декодується відстань, і відповідна кількість байт копіюється з уже розпакованої частини даних.
    * Записує відновлені дані у вихідний файл


## Обробка та Стиснення Аудіоданих у Форматі WAV - Кульбаба, Стаднік, Москв'як, Гоцуляк
 Метою є зменшення розміру аудіоданих без втрати якості (або з мінімальними контрольованими втратами, залежно від параметрів) для ефективного зберігання та передачі. Реалізація комбінує попередню обробку аудіосигналу за допомогою дельта-кодування з подальшим стисненням за алгоритмом Хаффмана.

### Загальний підхід до роботи зі звуком:

Аудіодані у WAV-файлах зазвичай представлені як послідовність числових значень (семплів), що відображають амплітуду звукової хвилі в певні моменти часу. Пряме стиснення цих значень може бути не завжди ефективним. Тому застосовується двоетапний підхід:

1.  **Перетворення та попередня обробка аудіосигналу (`audio_transforms.py`):**
    * **Конвертація даних:** Здійснюється перетворення "сирих" байтових даних з WAV-файлу в масив числових семплів, з якими легше проводити математичні операції. Також реалізовано зворотне перетворення.
    * **Дельта-кодування:** До послідовності семплів застосовується дельта-кодування. Замість збереження абсолютного значення кожного семплу, зберігається лише різниця між поточним та попереднім семплом. Перший семпл зберігається як опорний. Цей метод часто дозволяє зменшити динамічний діапазон значень, оскільки сусідні семпли в аудіосигналах зазвичай сильно корелюють. Такий підхід є спрощеним випадком диференціальної імпульсно-кодової модуляції ([DPCM](https://en.wikipedia.org/wiki/Differential_pulse-code_modulation)).

2.  **Стиснення підготовлених даних (`wav_compression_deflate.py` у поєднанні з `huffman_coding`):**
    * **Отримання дельта-значень:** Результат дельта-кодування (послідовність різниць) готується до основного етапу стиснення.
    * **Кодування Хаффманом:** До цих дельта-значень (або до оригінальних семплів, якщо дельта-кодування не застосовувалось) застосовується алгоритм кодування Хаффмана. Цей статистичний метод присвоює коротші кодові слова тим значенням, які зустрічаються частіше, і довші – тим, що рідше. Це дозволяє ефективно зменшити загальний обсяг даних.
    * **Збереження метаданих:** Разом зі стисненими даними зберігається необхідна службова інформація (параметри WAV-файлу, опорний семпл для дельта-декодування, словник кодів Хаффмана), яка потрібна для коректного відновлення вихідного аудіосигналу.

### Процес стиснення WAV-файлу:

1.  **Читання та аналіз:** Вхідний WAV-файл зчитується, визначаються його ключові характеристики (частота дискретизації, кількість каналів, розрядність).
2.  **Перетворення:** Аудіодані конвертуються з байтів у список числових семплів.
3.  **Дельта-кодування (опціонально, але рекомендовано):** До семплів застосовується дельта-кодування для зменшення надмірності.
4.  **Основне стиснення:** Отримана послідовність (дельт або семплів) стискається за допомогою алгоритму Хаффмана.
5.  **Формування вихідного файлу:** Стиснені дані разом із метаданими та словником Хаффмана записуються у вихідний файл.

### Процес декомпресії:

1.  **Читання метаданих:** Зі стисненого файлу зчитується службова інформація та словник Хаффмана.
2.  **Декодування Хаффманом:** Відновлюється послідовність дельта-значень (або семплів), використовуючи словник Хаффмана.
3.  **Дельта-декодування (якщо застосовувалось):** За допомогою опорного семплу та послідовності дельт відновлюються оригінальні значення семплів.
4.  **Формування WAV-файлу:** Відновлені семпли конвертуються назад у байтовий формат і записуються у новий WAV-файл з параметрами, збереженими в метаданих.



## UI та тестування - Оксана Москв'як
![image](https://github.com/user-attachments/assets/24c5d03f-13a5-4ef6-8043-fd31735a5a3f)
*Інтерфейс програми-кодека під час початку роботи*
<br>
<img width="788" alt="Screenshot 2025-05-07 at 10 05 36" src="https://github.com/user-attachments/assets/4b594776-2e4f-4665-b97f-608deca7babc" /> <br>
*Інтерфейс програми-кодека після компресії файлу. Зображено початковий розмір файлу та розмір стисненого файлу.*

Використані бібліотеки для UI:
- `PyQt6` - для безпосереднього створення застосунку.
- `os` - для доступу до файлів.
- `sys` - для запуску ui.

### Основні компоненти:
